{"ast":null,"code":"import * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { featureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { useProjectionId } from '../projection/node/id.mjs';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { SwitchLayoutGroupContext } from '../context/SwitchLayoutGroupContext.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\n\nfunction createMotionComponent(_ref) {\n  let {\n    preloadedFeatures,\n    createVisualElement,\n    projectionNodeConstructor,\n    useRender,\n    useVisualState,\n    Component\n  } = _ref;\n  preloadedFeatures && loadFeatures(preloadedFeatures);\n\n  function MotionComponent(props, externalRef) {\n    const configAndProps = { ...useContext(MotionConfigContext),\n      ...props,\n      layoutId: useLayoutId(props)\n    };\n    const {\n      isStatic\n    } = configAndProps;\n    let features = null;\n    const context = useCreateMotionContext(props);\n    /**\n     * Create a unique projection ID for this component. If a new component is added\n     * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\n     * us to measure it as soon as any layout effect flushes pending layout animations.\n     *\n     * Performance note: It'd be better not to have to search the DOM for these elements.\n     * For newly-entering components it could be enough to only correct treeScale, in which\n     * case we could mount in a scale-correction mode. This wouldn't be enough for\n     * shared element transitions however. Perhaps for those we could revert to a root node\n     * that gets forceRendered and layout animations are triggered on its layout effect.\n     */\n\n    const projectionId = isStatic ? undefined : useProjectionId();\n    /**\n     *\n     */\n\n    const visualState = useVisualState(props, isStatic);\n\n    if (!isStatic && isBrowser) {\n      /**\n       * Create a VisualElement for this component. A VisualElement provides a common\n       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n       * providing a way of rendering to these APIs outside of the React render loop\n       * for more performant animations and interactions\n       */\n      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\n      /**\n       * Load Motion gesture and animation features. These are rendered as renderless\n       * components so each feature can optionally make use of React lifecycle methods.\n       */\n\n      const lazyStrictMode = useContext(LazyContext).strict;\n      const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n\n      if (context.visualElement) {\n        features = context.visualElement.loadFeatures( // Note: Pass the full new combined props to correctly re-render dynamic feature components.\n        configAndProps, lazyStrictMode, preloadedFeatures, projectionId, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor, initialLayoutGroupConfig);\n      }\n    }\n    /**\n     * The mount order and hierarchy is specific to ensure our element ref\n     * is hydrated by the time features fire their effects.\n     */\n\n\n    return React.createElement(VisualElementHandler, {\n      visualElement: context.visualElement,\n      props: configAndProps\n    }, features, React.createElement(MotionContext.Provider, {\n      value: context\n    }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)));\n  }\n\n  const ForwardRefComponent = forwardRef(MotionComponent);\n  ForwardRefComponent[motionComponentSymbol] = Component;\n  return ForwardRefComponent;\n}\n\nfunction useLayoutId(_ref2) {\n  let {\n    layoutId\n  } = _ref2;\n  const layoutGroupId = useContext(LayoutGroupContext).id;\n  return layoutGroupId && layoutId !== undefined ? layoutGroupId + \"-\" + layoutId : layoutId;\n}\n\nexport { createMotionComponent };","map":{"version":3,"sources":["E:/react-portfolio/portfolio-starter/node_modules/framer-motion/dist/es/motion/index.mjs"],"names":["React","forwardRef","useContext","MotionConfigContext","MotionContext","useVisualElement","useMotionRef","useCreateMotionContext","featureDefinitions","loadFeatures","isBrowser","useProjectionId","LayoutGroupContext","VisualElementHandler","LazyContext","SwitchLayoutGroupContext","motionComponentSymbol","createMotionComponent","preloadedFeatures","createVisualElement","projectionNodeConstructor","useRender","useVisualState","Component","MotionComponent","props","externalRef","configAndProps","layoutId","useLayoutId","isStatic","features","context","projectionId","undefined","visualState","visualElement","lazyStrictMode","strict","initialLayoutGroupConfig","createElement","Provider","value","ForwardRefComponent","layoutGroupId","id"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { forwardRef, useContext } from 'react';\nimport { MotionConfigContext } from '../context/MotionConfigContext.mjs';\nimport { MotionContext } from '../context/MotionContext/index.mjs';\nimport { useVisualElement } from './utils/use-visual-element.mjs';\nimport { useMotionRef } from './utils/use-motion-ref.mjs';\nimport { useCreateMotionContext } from '../context/MotionContext/create.mjs';\nimport { featureDefinitions } from './features/definitions.mjs';\nimport { loadFeatures } from './features/load-features.mjs';\nimport { isBrowser } from '../utils/is-browser.mjs';\nimport { useProjectionId } from '../projection/node/id.mjs';\nimport { LayoutGroupContext } from '../context/LayoutGroupContext.mjs';\nimport { VisualElementHandler } from './utils/VisualElementHandler.mjs';\nimport { LazyContext } from '../context/LazyContext.mjs';\nimport { SwitchLayoutGroupContext } from '../context/SwitchLayoutGroupContext.mjs';\nimport { motionComponentSymbol } from './utils/symbol.mjs';\n\n/**\n * Create a `motion` component.\n *\n * This function accepts a Component argument, which can be either a string (ie \"div\"\n * for `motion.div`), or an actual React component.\n *\n * Alongside this is a config option which provides a way of rendering the provided\n * component \"offline\", or outside the React render cycle.\n */\nfunction createMotionComponent({ preloadedFeatures, createVisualElement, projectionNodeConstructor, useRender, useVisualState, Component, }) {\n    preloadedFeatures && loadFeatures(preloadedFeatures);\n    function MotionComponent(props, externalRef) {\n        const configAndProps = {\n            ...useContext(MotionConfigContext),\n            ...props,\n            layoutId: useLayoutId(props),\n        };\n        const { isStatic } = configAndProps;\n        let features = null;\n        const context = useCreateMotionContext(props);\n        /**\n         * Create a unique projection ID for this component. If a new component is added\n         * during a layout animation we'll use this to query the DOM and hydrate its ref early, allowing\n         * us to measure it as soon as any layout effect flushes pending layout animations.\n         *\n         * Performance note: It'd be better not to have to search the DOM for these elements.\n         * For newly-entering components it could be enough to only correct treeScale, in which\n         * case we could mount in a scale-correction mode. This wouldn't be enough for\n         * shared element transitions however. Perhaps for those we could revert to a root node\n         * that gets forceRendered and layout animations are triggered on its layout effect.\n         */\n        const projectionId = isStatic ? undefined : useProjectionId();\n        /**\n         *\n         */\n        const visualState = useVisualState(props, isStatic);\n        if (!isStatic && isBrowser) {\n            /**\n             * Create a VisualElement for this component. A VisualElement provides a common\n             * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as\n             * providing a way of rendering to these APIs outside of the React render loop\n             * for more performant animations and interactions\n             */\n            context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement);\n            /**\n             * Load Motion gesture and animation features. These are rendered as renderless\n             * components so each feature can optionally make use of React lifecycle methods.\n             */\n            const lazyStrictMode = useContext(LazyContext).strict;\n            const initialLayoutGroupConfig = useContext(SwitchLayoutGroupContext);\n            if (context.visualElement) {\n                features = context.visualElement.loadFeatures(\n                // Note: Pass the full new combined props to correctly re-render dynamic feature components.\n                configAndProps, lazyStrictMode, preloadedFeatures, projectionId, projectionNodeConstructor ||\n                    featureDefinitions.projectionNodeConstructor, initialLayoutGroupConfig);\n            }\n        }\n        /**\n         * The mount order and hierarchy is specific to ensure our element ref\n         * is hydrated by the time features fire their effects.\n         */\n        return (React.createElement(VisualElementHandler, { visualElement: context.visualElement, props: configAndProps },\n            features,\n            React.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement))));\n    }\n    const ForwardRefComponent = forwardRef(MotionComponent);\n    ForwardRefComponent[motionComponentSymbol] = Component;\n    return ForwardRefComponent;\n}\nfunction useLayoutId({ layoutId }) {\n    const layoutGroupId = useContext(LayoutGroupContext).id;\n    return layoutGroupId && layoutId !== undefined\n        ? layoutGroupId + \"-\" + layoutId\n        : layoutId;\n}\n\nexport { createMotionComponent };\n"]},"metadata":{},"sourceType":"module"}